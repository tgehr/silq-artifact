// ../silq/silq invalid.slq
// Figure 5.

def useConsumed(x:ğ”¹){
	y := H(x);    // consumes x
	return (x,y); // error: undefined identifier x
}

def useConsumedFixed(const x:ğ”¹){
	y:=H(x);
	return (x,y); // ok
}

def discard[n:!â„•](x:uint[n]){ // error: parameter 'x' is not consumed
	y := x % 2;
	return y;
}

def nonQfree(const x:ğ”¹,y:ğ”¹){
	if H(x) { y := X(y); } // error: non-'lifted' quantum expression must be consumed
	return y;
}

def nonConst(c:ğ”¹){
	if X(c) { phase(Ï€); } // error: non-'lifted' quantum expression must be consumed
}

def nonConstFixed(const x:ğ”¹){
	if X(x) { phase(Ï€); } // ok
}

def condMeas(const c:ğ”¹,x:ğ”¹){
	if c { x := measure(x); } // error: cannot call function 'measure[ğ”¹]' in mfree context
}

def revMeas(){
	return reverse(measure[ğ”¹]); // error: reversed function must be 'mfree'
	// note: the example shown in the paper is simplified:
	//  measure is a generic function and in a future version of Silq,
	//  we plan to automatically rewrite the expression
	//  `reverse(measure)` to the generic function [a]â‡’reverse(measure[a])
}
