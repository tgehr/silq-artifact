// ../silq/silq --run grover.slq
// Figure 3.

def groverDiffusion[n:!â„•](cand:uint[n])mfree: uint[n]{
	for k in [0..n) { cand[k] := H(cand[k]); }
	if cand!=0{ phase(Ï€); }
	for k in [0..n) { cand[k] := H(cand[k]); }
	return cand;
}

def grover[n:!â„•](f: const uint[n] !â†’ lifted ğ”¹):!â„•{
	nIterations:=floor(Ï€/(4Â·asin(2^(-n/2))));
	cand:=0:uint[n];
    for k in [0..n){ cand[k]:=H(cand[k]); }
	for k in [0..nIterations){
		if f(cand){ phase(Ï€); }
		cand:=groverDiffusion(cand);
	}
	return measure(cand) as !â„•;
}

def main(){
	def oracle(x:uint[6])lifted{
		return x%2=0 && x%3=0 && x%5â‰ 0 && x%7=0;
	}
	return grover(oracle);
}
